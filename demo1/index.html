<!DOCTYPE html>
<html>
<head>
    <title></title>
</head>
<body>
<div id="example">
    <p>Original message: "{{ message }}"</p>
    <p>Computed reversed message: "{{ reversedMessage1 }}"</p>
    <p>Computed reversed message: "{{ reversedMessage2() }}"</p>





    <!-- 阻止单击事件冒泡 -->
    <a v-on:click.stop="doThis"></a>
    <!-- 提交事件不再重载页面 -->
    <form v-on:submit.prevent="onSubmit"></form>
    <!-- 修饰符可以串联  -->
    <a v-on:click.stop.prevent="doThat"></a>
    <!-- 只有修饰符 -->
    <form v-on:submit.prevent></form>
    <!-- 添加事件侦听器时使用事件捕获模式 -->
    <div v-on:click.capture="doThis">...</div>
    <!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 -->
    <div v-on:click.self="doThat">...</div>
    <!-- 点击事件将只会触发一次 -->
    <a v-on:click.once="doThis"></a>

    <!--只有在 keyCode 是 enter 时调用 vm.submit()  -->
    <input v-on:keyup.enter="submit">
    <!-- 缩写语法 -->
    <input @keyup.enter="submit">
</div>
<script src="../src/vue.js"></script>
<script>
    var vm = new Vue({
        el: '#example',
        data: {
            message: 'Hello'
        },
        //computed只有数据改变时才会重新计算
        computed: {
            // a computed getter
            reversedMessage1: function () {
                // `this` points to the vm instance
                return this.message.split('').reverse().join('')
            }
        },
        //method 只要重新渲染就会重新计算
        methods: {
            reversedMessage2: function () {
                return this.message.split('').reverse().join('')
            }
        }
    })
</script>
</body>
</html>